# 实模式下的内存布局

| 起始 |结束  |大小  | 用途 |
| --- | --- | --- | --- |
| FFFF0 | FFFFF | 16B | BIOS入口地址，此地址也属于BIOS代码，同样属于顶部的640KB字节。只是为了强调其入口地址才单独贴出来。此处16字节的内容的跳转指令jmp f00:e05b |
| F0000 | FFFEF | 65KB - 16B |系统BIOS范围是F0000 ~ FFFFF共640KB，为说明入口地址，将最上面的16字节从此处去掉了，所以此处终止地址是0XFFFEF  |
| C8000 | EFFFF | 160KB | 映射硬件适配器的ROM或内存映射式I/O |
| C0000 | C7FFF | 32KB | 现实适配其BIOS |
| B8000 | BFFFF | 32KB |用于文本模式现实适配器  |
| B0000 | B7FFF | 32KB | 用于黑白现实适配器 |
| A0000 | AFFFF | 64KB | 用于彩色现实适配器 |
| 9FC00 | 9FFFF | 1KB | EBDA(Extended BIOS Data Area)扩展BIOS数据区 |
| 7E00 | 9FBFF | 622080B约608KB | 可用区域 |
| 7C00 | 7DFF | 512B |MBR被BIOS加载到此处，共512字节  |
| 500 | 7BFF | 30464B 约 30KB | 可用区域  |
| 400 | 4FF | 256B | BIOS Data Area(BISO 数据区) |
| 000 | 3FF | 1KB | Interrupt Vector Table(中断向量表) |

# BIOS 是如何被启动的？
因为BIOS是计算机上的第一个运行的软件，它是由硬件加载的。这个硬件是只读存储器ROM, BISO代码所做的工作是一成不变的，所以BIOS顺理成章地被写入ROM，ROM也是快内存，内存就需要被访问

此ROM 被映射在低端1MB内存的顶部，即地址0xF0000 ~ 0xFFFFF处

BIOS本身也是个程序，程序要执行，就要有个入口地址才行，此入口地址就是0xFFFF0

# CPU中的cs:ip值是如何组合成0xFFFF0?
由于在实模式下，段地址需要乘以16后才能与偏移地址相加，求出的和便是物理地址，CPU便拿出地址直接用了

在开机的一瞬间，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0。由于开始的时候处于实模式，在实模式下的段地址要乘以16，也就是左移4位，于是0xF000:0xFFF0的等效地址将是0xFFFF0。此地址就是BIOS的入口地址

# 加载BIOS后，CPU的下一条指令？
BIOS是在实模式下运行的，而实模式只能访问1MB空间(20位地址线，2的20次方是1MB)。而地址0xFFFF0距1MB只有16个字节

这么小的空间够干嘛？BIOS又要检测硬件，做各种初始化工作，还要建立中断向量表。如果超过寄存器的宽度，比如0xFFFF0+16，就溢出了。由于实模式下的寄存器是16位的，0xFFFF0+16已经超过其最大值0xFFFFF,溢出的部分就会卷到0，又会重新开始。即0xFFFF0+16=0，0xFFFF0+16=1

所以0xFFFF0地址内的指令是 jmp far f000:e05b,跳转到0xfe05b处，这是BIOS代码真正开始的地方

然后就是BIOS开始检测内存、显卡等外设信息。当检测通过，并初始化好硬件后，开始在内存中0x000 ~ 0x3FF处建立数据结构，中断向量表IVT并填写中断例程

# 0盘0道1扇区
0盘0道1扇区就相当于0盘0道0扇区

为什么称为1，因为硬盘扇区的表示法有两种，0盘0道1扇区用的便是其中一种:CHS方法(柱面Cylinder、磁道Header、扇区Sector),另一种是LBA. 

`0盘`说的是0磁头，因为一张盘是有上下两个盘面的，一个盘面上对应一个磁头，所以用磁头Header来表示盘面

`0道`是指0柱面，柱面Cylinder指的是所有盘面上、编号相同的磁道的集合，形象一点描述就是把很多环叠摞在一起的样子，组合在一起之后是一个立体的管状

`1扇区`，将磁道等距划分成一段段的小区间，由于磁道是圆形的，确切地说圆环，这些被划分出来的小区间便是扇形，所以被称为扇区

如果此扇区末尾的两个字节分别是魔数0x55和0xaa，BIOS便认为此扇区中确实存在可执行的程序(MBR)，便加载物理地址0x7c00，随后跳转到此地址，继续执行