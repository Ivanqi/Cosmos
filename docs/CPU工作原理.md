
# CPU 内部划分
## 概述
控制单元、运算单元、存储单元

## 控制单元
控制单元大致由`指令寄存器IR(Instruction Register)`、`指令译码器ID(Instruction Decoder)`、`操作控制器OC(Operation Controller)`

程序被加载到内存后，也就是指令这时都在内存中来，`指令指针寄存器`IP指向内存中下一条待执行指令的地址

控制单元根据IP寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中，但它还不是这些是什么，在它眼里的0101串词是还没有实际意义

然后`指令译码器`将位于`指令寄存器`的指令按照指令格式来解码，分析出操作码是什么，操作在哪里之类的

操作码是指 mov,jmp等

## 存储单元
存储单元是指CPU内部的L1、L2缓存及寄存器，待处理的数据(操作数)就存放在这些存储但中

## 运算单元
运算单元负责算术运算(加减乘除)和逻辑运算(比较、移位)，它从控制单元那里接收命令命令(并执行)

# CPU工作原理
## CPU工作原理图例
![cce3fc24c06def5d81a65d4f13ff40f1.png](evernotecid://95103871-7E20-47B6-A8DD-62C60FAB24B1/appyinxiangcom/15513169/ENResource/p14325)@w=500

## 概述
控制单元要取下一条待运行的指令，该指令的地址在程序计数器PC。在x86CPU上，程序计数器就是cs:ip

于是读取ip寄存器后，将此地址送上地址总线，CPU根据此地址便得到了指令，并将其存入到指令寄存器IR中

这时轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型。若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接使用，免了取操作数这一个过程

操作码有了，操作数也齐了，操作控制器给运算单元下令，于是运算单元便真正开始执行指令了

ip寄存器的值被加上当前指令的大小，于是ip又指向了下一条指令的地址。接着控制单元又要取下一条指令了，流程回到了本段开头，CPU便开始日复一日的循环


# CPU中寄存器分为两类
## 一类其内部使用，对程序员不可见
“是否可见”不是说寄存器是否能看得见，是指程序员是否能使用

CPU内部有其自己的运行机制，是按照某个预定框架进行的，为了CPU能够运行下去，必然会有一些寄存器来做数据的支撑，给CPU内部的数据提供存储空间

这一部分对外是不可见的，我们无法使用它们，比如全局描述符表寄存器GDTR、中断描述符表寄存器IDTR、局部描述符表寄存器LDTR、任务寄存器TR、控制器寄存器CR0 ~ 3、指令指针寄存器IP、标志寄存器flags、调试寄存器DR0~7

全局描述符表寄存器GDTR，通过lgdt指令为其指定全局描述符表的地址及偏移量

对于中断描述符表寄存器IDTR，通过lidt指令为其指定中断描述符表的地址

而局部描述符表寄存器LDTR，可以用lgdt指令为其指定局部描述符ldt

对于任务寄存器TR，可以用ltr指令为其指定一个任务状态段tss

对于flags寄存器，系统提供了pushf和popf指令，分别用于将flags寄存器的内容压入栈，将栈中内容弹到flags寄存器

## 另一类是对程序员可见的寄存器
能够直接操作的就是这些寄存器，比如段寄存器、通用寄存器