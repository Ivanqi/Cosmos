# 概述
`TSS，即Task State Segment, 意为任务状态段`，它是处理器在硬件上原生支持多任务的一种实现方式，也就是说处理器原本是想让操作系统开发厂商利用此结构实现多任务的

TSS 是一种数据结构，它用于存储任务的环境
![avatar](../images/tss_1.png)

TSS 是每个任务都有的结构，它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段

该结构看上去也有点复杂，里面众多寄存器都囊括这104字节，其中这104字节只是TSS的最小尺寸，根据需要还可以再接上个IO位图


# 任务与TSS
## 任务的特权级别与栈
任务是由处理器执行的，任务在特权级变换时，本质上是处理器的当前特权级别在变换，由一个特权级变成另外一个特权级

处理器固定，处理器在不同特权级下，应该用不同特权级的栈，原因是如果在同一栈中容纳所有特权级的数据时，这种交叉引用会使栈变得非常混乱，并且，用一个栈容纳多个特权级下的数据，栈容量有限
- 例子，处理器位于0特权级时要用0特权级别的栈，3特权级下也只能用3特权级别下的

每个任务的每个特权级下只能由一个栈，不存在一个任务的某个特权级下存在多个同特权级栈的情况
- 也就是说，一共4个特权级，一个任务"最多"有4个栈

既然一个TSS代表一个任务，每个任务又有4个栈，那么为什么TSS中只有3个栈: ss0和esp0、ss1和esp1、ss2和esp2?
- 它们分别代表0级栈的段选择子和偏移量、1级栈的段选择子和偏移量、2级栈的段选择子和偏移量

## TSS中记录的3个栈是干嘛的？
特权级转移分为两类
- 一类是由中断门、调用门等手段实现低特权级转向高特权级
- 另一类则相反，是由调用返回指令从高特权级别返回到低特权级别，这是唯一一种能让处理器降低特权级的情况

### 特权级由低到高的情况
对于第1种 - 特权级由低到高的情况，由于不知道目标特权级对应的栈地址在哪里，所有要提前把目标栈的地址记录在某个地方

当处理器向高特权级转移再从中取出来加载到SS和ESP中以更新栈，这个保存的地方就是TSS，处理器会自动从TSS中找到对应的高特权级栈地址

也就是说，除了调用返回外，处理器只能由低特权级向高特权级转移，TSS中所记录的栈是转移后的高特权级目标栈，所以它一定比当前使用的栈，所以它一定比当前使用的栈特权级要高，只用于向更高特权级别转移时提供相应特权的栈地址

进一步说，TSS中不需要记录3特权级的栈，因为3特权级是最低的，没有更低的特权级会向它转移

不是每个任务都有4个栈，一个任务可拥有的栈数量取决于当前特权级是否还有进一步提高的的可能，即取决于它最低的特权级别
- 比如3特权级的程序，它是最低的特权级，还能提升3级，所有可额外拥有2、1、0特权级栈，用于将特权级分别转移到2、1、0级时使用
- 2特权级别的程序，它还可以提升2级，所以额外拥有1、0特权级栈，用于将特权级分别转移到1、0级时使用
- 1特权级的程序，它可以额外拥有0特权级栈
- 0特权级已经是至高无上，只有一个0级栈

以上所说的低特权级转向高特权级的过程称为`向内层转移`

### 高特权返回低特权级别的情况
对于第2种 - 由高特权返回到低特权级的情况，处理器是不需要在TSS中去寻找低特权级别目标栈的

因为，TSS中只记录2、1、0特权级的栈，假如是从2特权级返回到3特权级，上哪找3特权级？另一方面的原因是低特权级栈的地址其实已经存在了，这是由处理器的向高特权级转移指令(如int、call等)实现的机制决定的，换句话说，处理器知道去哪里找低特权级的目标栈

由于特权级向低转移后，处理器特权级有了变化，同样也需要将当前栈更新为低特权级别的栈，它如何找到对应的低特权级别的栈？
- 正常情况下，特权级由低向高转移在先，由高向低返回在后，即只有先向更高特权级转移，才能谈得上再从高特权级回到低特权级，否则没有“去”就谈不上“回”
- 当处理器由低向高特权级转移时，它自动地把当时低特权级的战地址(SS 和 ESP)压入了转移后的高特权级所在的栈中。所以，当用返回指令如 retf 或iret 从高特权级向低特权级返回时，处理器可以从当前使用的高特权级的战中获取低特权级的钱段选择子及偏移量
- 由高特权级返回低特权级的过程称为“向外层转移”

当下次处理器再进入高特权级时，它依然会在TSS中寻找对应的高特权级栈，而TSS中栈指针都是固定的，每次进入高特权级都会重复使用它们

也就是说，即使曾经转移到高特权级下用过高特权级栈，处理器也不会自动把该高特权级栈指针更新到TSS中，因为在从高特权级返回时，处理器需要把栈更新为低特权级的栈选择子及esp指针

而原先在段寄存器SS和寄存器esp中高特权级下的战段选择子及指针会被处理器自动丢弃。换句话说，如果想保留上一次高特权级的栈指针，得手动更新 TSS 中相应栈的数据。

### 处理器是怎样找到TSS?
TSS 是硬件支持的系统数据结构，它和 GDT 等一样，由软件填写其内容，由硬件使用

GDT 也要加载到寄存器 GDTR 中才能被处理器找到， TSS 也是一样，它是由 TR ( Task Register ）寄存器加载的，每次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS 就成了