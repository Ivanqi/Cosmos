# 线性地址
![avatar](../images/page_table_2.png)
## 分段模式下的线性地址
在保护模式中段寄存器中的内容已经是选择子，但选择子最终就是为了要找到段基址，其内存访问的核心机制依然是"段基址 + 段内偏移地址"，这两个地址相加之后才是绝对地址，也就是`线性地址`

此线性地址在分段机制下被CPU认为是物理地址，直接能拿来使用，也就是说，此线性地址可以直接送上地址总线

将段基址和段内偏移地址相加求和的工作是由CPU的段部件自动完成的。如`图5-6`所示

## 分页模式下的线性地址
`图5-7`说明，CPU在不打开分页机制的情况下，是按照默认的分段方式进行的，段基址和段内偏移地址经过段部件处理后输出线性地址，CPU就认为是物理地址

如果打开了分页机制，段部件输出的线性地址就不等同物理地址，被称之为`虚拟地址`。它是逻辑上的，是假的


# 分页机制的作用
## 作用简述
将线性地址转换成物理地址

用大小相等的页代替大小不等的段

## 过程
![avatar](../images/page_table_2.png)
上图表示的一个进程地址转换过程，从线性空间到虚拟地址再到物理地址空间，每个空间大小都是4GB

4GB的物理地址空间属于所有进程包括操作系统在内的共享资源，其中标注为已分配页的内存块被分配给力其他进程，当前进程只能使用未分配页

此转换过程对任意一个进程都是一样的，也就是说，每个进程都有自己的4GB虚拟空间

分页机制建立在分段机制之上，与其脱离不了干系，即使在分页机制下的进程也要经过逻辑上的分段才行，每个加载一个进程，操作系统按照进程中各段的起始范围，在进程自己的4GB虚拟地址空间寻找可用空间分配内存段

此虚拟地址空间可以是页表，也可以是操作系统维护的某种数据结构，总之此阶段的分配是逻辑上的，并没有写入物理内存

在分页机制下，代码段和数据段在逻辑上被拆分成以页为单位的小内存块。这时的虚拟地址虚如其名，不能存放任何数据。接着操作系统开始为这些虚拟内存分页真实物理内存，它查找物理内存中可以用的页，然后在页表中登记这些物理地址，这样就完成了虚拟页到物理页的映射，每个进程都以为自己独享4GB地址空间


# 页
页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是4KB的地址空间都可以称为一页，所以线性地址的一页也要对应物理地址的一页

一页大小为4KB，这样一来，4GB地址空间被划分为4GB/4KM=1M个页，也就是4GB空间中可以容纳1048576个页

![avatar](../images/page_table_2.png)
- 由于页大小是4KB，所以页表项中的物理地址都是4k的整数倍，故用十六进制表示的地址，低3位都是0
- 就拿第3个页表项，其值为0x3000,表示该页对应的物理地址是0x3000


