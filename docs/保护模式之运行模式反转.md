# 运行模式的寄存器
![avatar](../images/protection_mode_1.png)

在这个格式中第3个字段用于指定寻址方式和操作数类型，在指令格式不变的情况下，为了兼容保护模式，一种方案是重新定义各寻址方式、寄存器编码
- 由于保护模式中的寻址方式和操作数类型同实模式下完全不同，故相应的编码也不同
- 比如在实模式下，用二进制010表示dx寄存器，在保护模式下的010就表示edx寄存器(根据编码确定指令、寻址方式、寄存器、这是译码器的工作)
- 操作dx寄存器和edx寄存器，对于硬件来说是完全不同的，所以编译器必须明确操作对象是哪个

# 兼容性两面性
兼容性带来了好处，也带来了坏处，好处是CPU很强大，可以同时支持16位指令和32位指令，运行新来程序畅通无阻。但坏处就是CPU也不知道您想生成16位，还是32位机器码，这就是前面说过的，需要明确告诉编译器一些信息

编译器提供了伪指令bits，用它来向编译器传达:
- 下面的指令都要编译成xx位的，因为不知道下面的代码的运行环境是xx模式
    - 比如在实模式下，运行指令都是16位的，所以编译器要将代码编译成16位的指令
    - 在实模式下准备好了保护模式所需要的环境后，进入保护模式后的代码就应该是32位指令
    - 也就是，同一段程序要经历两种模式，所以同一段程序中有两种模式的机器码
- bits的指令格式[bits 16]或[bits 32]
    - [bits 16]是告诉编译器，下面的代码帮我编译成16位的机器码
    - [bits 32]是告诉编译器，下面的代码帮我编译成32位的机器码
- "下面的代码"是那里的？
    - bits指令的范围是从当前bits标签直到下一个bits标签的范围，这个范围中的代码将被编译成相应字长的机器码
    - bit外面的中括号是可以省略的，另外，在未使用bits指令的指令，模式是[bits 16]
    
进入保护模式需要三个步骤
- 打开A20
- 加载gdt
- 将cr0的pe位置1