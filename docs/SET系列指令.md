# 概念
set系列指令，作用为根据EFLAGS寄存器中的状态标识设置目标操作数的值为0或1

目标操作数指向一个字节寄存器或内存中的一字节

# SET指令访问条件码
## CF: 进位标志
最近的操作使最高位产生了进位。可用来检查无符号操作的溢出

## ZF: 零标志
最近的操作得出的结果为0

## SF: 符号标志
最近的操作得到的结果为负数

## OF: 溢出标志
最近的操作导致一个补码溢出 - 正溢出或负溢出

# SET 指令

| 指令 | 同义名 | 效果 | 设置条件 |
| --- | --- | --- | --- |
| sete D | setz | D <- ZF | 相等/零 |
| setne D | setnz | D <- ~ZF | 不想等/非零 |
| sets D |  | D <-  SF | 负数 |
| setns D |  | D <- ~SF | 非负数 |
| setg D | setnle | D <- ~(SF ^ OF) & ~ZF | 大于(有符号 >) |
| setge D | setnl | D <- ~(SF ^ OF)  | 大于等于(有符号>=) |
| setl D | setnge |D <- SF ^ OF  | 小于(有符号<) |
| setle D | setng | D <- (SF ^ OF) | ZF | 小于等于(有符号 <=) |
| seta D | setnbe | D <- ~CF & ~ZF |  超过(无符号 >) |
| setae D | setnb | D <- ~CF | 超过或想等(无符号>=) |
| setb D | setnae | D <- CF | 低于(无符号<) |
| setbe D| setna | D <- CF | ZF | 低于或相等(无符号 <=) |

SET指令根据条件码或者条件码的组合将一个字设置为0或1(所以如果set指令后面跟的是寄存器，那么必须是单字节的寄存器)

在经过了比较指令 a < b， 即有 t = a - b后，就会根据运算的过程和结果设置条件码。注意不管是无符号还是补码数，t一定是发生溢出后的截断结果(如果发生溢出)

# 指令分析
## 分析有符号数指令
### 分析setl
因为这个看起来是这四条里面最简单的

当SF ^ OF为1时(此条指令代表的是 a < b，即为1时有 a < b)，会将D设置为1，否则设置为0

有两种情况`SF ^ OF`为1:
- `SF = 1 OF = 0`，此时`OF = 0`即没有发生溢出，那么结果t就是正常结果`SF = 1`即结果t是负数，即 a - b < 0即 a < b。符合情况
- `SF = 0 OF = 1`，此时`OF = 1`即发生了溢出，且`SF = 0`说明结果t为非负数，所以很明显这里是发生的负溢出，所以溢出结果为负数。a - b >= 0这里负溢出，所以两个部分为负，a为负, -b为负，所以b为正，既然a为负，b为正，那儿必有 a < b。符合情况

### 分析setle
既然 `SF ^ OF = 1` 代表小于且`ZF = 1`代表等于，那么`(SF ^ OF) | ZF = 1`就代表小于或等于

### 分析setge
既然 `SF ^ OF = 1`代表小于，那么整体取反后，`~(SF ^ OF) = 1`，就代表大于等于。(小于的反面就是大于等于)


### 分析setg
既然 `(SF ^ OF) | ZF =1` 就代表小于等于，那么整体取反后, `~(SF ^ OF) & ~ZF =1` (注意取反后或符号变为与符号)，就代表大于


## 分析无符号数
分析过程跟上面一样

### CF进位标志的作用
1. 当两个数相加时，若最高位向上形成进位，则CF=1
2. 当两个数相减时，若最高位向上形成借位，则CF=1
3. 当两个无符号数相乘，若乘积的高一半为0，则CF=0
4. 当两个带符号数相乘，若乘积的高一半是低一半的符号扩展，则CF=0


# 参考资料
- [汇编中set指令是什么意思](https://zhidao.baidu.com/question/564086751.html)
- [汇编set指令（32位）AT&T格式](https://www.cnblogs.com/oBYBo/p/13028964.html)
- [《深入理解计算机系统》练习题3.13-3.16 set指令 跳转指令编码](https://blog.csdn.net/anlian523/article/details/84350867)